import difflib
from collections import defaultdict
from family_tree.color import ColorChooser
from family_tree.semester import Semester

class TreeEntity:
    '''

    Analogous to a single row in the directory, except that the fields have
    been combined appropriately (i.e., first/preferred/last names combined into
    one field, or semester strings converted to Semester objects).

    Entities are assumed to implement these functions:

        + get_key(self): Returns the key to be used in DOT

        + dot_node_attributes(self): Returns the node attributes to be used in DOT

        + dot_edge_attributes(self, other): Returns the edge attributes to be
        used in DOT, for all outgoing edges

        + semester: A field storing a Semester object, used to determine the
        entity's rank in DOT

    Generally, TreeEntity subclasses should also implement:

        + Factory methods that generate new TreeEntities from rows

        + Validation functions that catch invalid values for fields used to
        create them

    '''

    def __init__(self):
        self.semester = None

    def get_key(self):
        raise NotImplementedError

    ###########################################################################
    #### DOT Functions                                                     ####
    ###########################################################################

    def dot_node_attributes(self):
        return {}

    def dot_edge_attributes(self, other):
        return {}

    ###########################################################################
    #### Validation Functions                                              ####
    ###########################################################################

    # empty

class UnidentifiedKnight(TreeEntity):
    '''
    All members are assumed to have big brothers. If a member does not have a
    known big brother, this class is used as a placeholder. UnidentifiedKnights
    are given pledge semesters a semester before the members they are bigs to.
    '''

    def __init__(self, semester, key):
        self.semester = semester
        self.key = key

    def get_key(self):
        return '{} Parent'.format(self.key)

    ###########################################################################
    #### Validation Functions                                              ####
    ###########################################################################

    @classmethod
    def from_member(cls, member):
        return cls(member.semester - 1, member.get_key())

    ###########################################################################
    #### DOT Functions                                                     ####
    ###########################################################################

    # inherit

class Member(TreeEntity):

    color_chooser = ColorChooser.from_graphviz_colors()
    family_colors = defaultdict(color_chooser.next_color)

    def __init__(self):
        self.badge = None
        self.name = None
        self.semester = None
        self.parent = None
        self.affiliations = []

    ###########################################################################
    #### Validation Functions                                              ####
    ###########################################################################

    @classmethod
    def from_dict(cls,
            badge=None,
            first_name=None,
            preferred_name=None,
            last_name=None,
            big_badge=None,
            pledge_semester=None,
            status=None,
            **rest):
        '''
        Create and validate a new Member object of the appropriate subclass,
        using a row of data generated by one of the readers. Return a Member
        if there is actually a member to return (i.e., if the member is not a
        reaffiliate).
        '''

        if status in ('Active', 'Alumni'):
            MemberType = Knight
        elif status == 'Brother':
            MemberType = Brother
        elif status == 'Candidate':
            MemberType = Candidate
        elif status == 'Expelled':
            MemberType = Expelled
        elif status == 'Reaffiliate':
            return None
        else:
            raise EntityError('Invalid member status: {}'.format(status))

        member = MemberType()
        member.badge = MemberType.validate_row_badge(badge)
        member.name = MemberType.validate_row_name(first_name, preferred_name, last_name)
        member.semester = MemberType.validate_row_semester(pledge_semester)
        member.parent = MemberType.validate_row_parent(big_badge);

        return member

    @classmethod
    def validate_row_badge(cls, badge_string):
        '''
        By default, badge numbers should be interpretable as integers. However,
        the actual key used should be a string (because Graphviz treats all
        node keys as strings).

        '''

        try:
            int(badge_string)
        except ValueError:
            # TODO better error message reflecting integer requirement
            raise EntityError('Unexpected badge number: "{}"'.format(badge_string))

        return badge_string

    @classmethod
    def validate_row_name(cls, first_name, preferred_name, last_name):
        '''
        Combine the member's names into a full, informal name.
        '''

        if first_name and last_name:
            return combine_names(first_name, preferred_name, last_name)
        else:
            raise EntityError('Missing first or last name')


    @classmethod
    def validate_row_parent(cls, big_badge_string):
        '''
        If the big's badge is known, then it should be interpretable as an
        integer.
        '''

        if big_badge_string:
            try:
                int(big_badge_string)
            except ValueError:
                # TODO reflect integer requirement
                raise EntityError('Unexpected big badge number: "{}"'.format(big_badge_string))
            # TODO is there a simpler way for all of this?
            return big_badge_string
        else:
            return None

    @classmethod
    def validate_row_semester(cls, semester_string):
        # We will not know if we really need the semester's value until later
        try:
            return Semester(semester_string)
        except (TypeError, ValueError):
            return None


    ###########################################################################
    #### DOT Functions                                                     ####
    ###########################################################################

    def get_dot_label(self):
        return ''

    def dot_node_attributes(self):
        return {
                'label' : self.get_dot_label(),
                }

class Knight(Member):

    def get_key(self):
        return self.badge

    ###########################################################################
    #### Validation Functions                                              ####
    ###########################################################################

    # inherit

    ###########################################################################
    #### DOT Functions                                                     ####
    ###########################################################################

    def get_dot_label(self):
        # TODO handle reaffiliates
        affiliations = ['ΔA {}'.format(self.badge)] + self.affiliations
        return '{}\\n{}'.format(self.name, ', '.join(affiliations))

class Brother(Member):

    bid = 0

    def __init__(self):
        '''
        Brothers who are not also Knights do not have badge numbers; use a
        simple counter to use as a key.
        '''

        super().__init__()
        self.key = 'Brother {}'.format(Brother.bid)
        Brother.bid += 1

    def get_key(self):
        return self.key

    ###########################################################################
    #### Validation Functions                                              ####
    ###########################################################################

    @classmethod
    def validate_row_badge(cls, badge_string):
        if badge_string:
            raise EntityError('Unknighted brothers do not have badge numbers')
        else:
            return None

    @classmethod
    def validate_row_name(cls, first_name, preferred_name, last_name):
        '''
        Brothers-not-Knights need only a last name (because the actual physical
        family tree had no first names).
        '''

        if last_name:
            return last_name
        else:
            return EntityError('Missing last name')

    ###########################################################################
    #### DOT Functions                                                     ####
    ###########################################################################

    def get_dot_label(self):
        return '{}\\nΔA Brother'.format(self.name)

class Candidate(Member):

    cid = 0

    def __init__(self):
        '''
        Candidates do not have badge numbers; use a simple counter to use as a
        key.
        '''

        super().__init__(self)
        self.key = 'Candidate {}'.format(Candidate.cid)
        Candidate.cid += 1

    def get_key(self):
        return self.key

    ###########################################################################
    #### Validation Functions                                              ####
    ###########################################################################

    @classmethod
    def validate_row_badge(cls, badge_string):
        if badge_string:
            raise EntityError('Candidates do not have badge numbers')
        else:
            return None

    ###########################################################################
    #### DOT Functions                                                     ####
    ###########################################################################

    def get_dot_label(self):
        return '{}\\nΔA Candidate'.format(self.name)

class Expelled(Knight):

    ###########################################################################
    #### Validation Functions                                              ####
    ###########################################################################

    @classmethod
    def validate_row_name(cls, first_name, preferred_name, last_name):
        if first_name and last_name:
            # They *should* have a name, but it's not going to be displayed
            return 'Member Expelled'
        else:
            raise EntityError('Missing first or last name')

    ###########################################################################
    #### DOT Functions                                                     ####
    ###########################################################################

    def get_dot_label(self):
        return '{}\\n{}'.format(self.name, self.badge)

def combine_names(first_name, preferred_name, last_name, threshold=.5):
    '''
    Returns
    =======

    + Either: "[preferred] [last]" if the `preferred` is not too similar to
    `last`, depending on the threshold

    + Or: "[first] [last]" if `preferred` is too similar to `last`

    Notes
    =====

    This might provide a marginally incorrect name for those who
       a. go by something other than their first name that
       b. is similar to their last name,
    but otherwise it should almost always[^note] provide something reasonable.

    The whole point here is to
       a. avoid using *only* last names on the tree, while
       b. using the "first" names brothers actually go by, and while
       c. avoiding using a first name that is a variant of the last name.

    [^note]: I say "almost always" because, for example, someone with the
    last name "Richards" who goes by "Dick" will be listed incorrectly as "Dick
    Richards" even if his other names are neither Dick nor Richard (unless the
    tolerance threshold is made very low).
    '''

    if preferred_name and difflib.SequenceMatcher(None, preferred_name, last_name).ratio() < threshold:
        first_name = preferred_name

    return '{} {}'.format(first_name, last_name)

class EntityError(Exception):
    pass
